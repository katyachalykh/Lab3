= Работа в IAR Embedded Workbench

=== *_Первое задание:_*
_Настроить внешний источник частоты HSE и
подключить его на системную шину._

_Прошить программу морганиями светодиодом -- проверить, что они
моргают._

Для начала необходимо создать проект C++ в программе
*IAR Embedded Workbench* (рисунок 1).

.Создание проекта в программе
image::Pics/file.png[]

Код программы и запуск представлены на рисунке 2.

.Устанока внешнего источника частоты HSE
image::Pics/file__2.png[]

После того как программа была запущена, видно, что светодиод на
плате начал мограть.

Частота внешнего высокочастотного
генератора частоты (HSE) равна 8 МГц.

=== *_Второе задание:_*
_Настроить внутренний источник частоты HSI и
подключить его на системную шину._

_Прошить программу морганиями светодиодом --
проверить, что они моргают быстрее в 2 раза._

На рисунке 3 представлена установка внутреннего источника частоты HSI.

.Установка внутреннего источника частоты HSI
image::Pics/file_3.jpg[]

После того  как программа была запущена, видно, что светодиод на плате
начал мограть в два раза быстрее, чем в первом случае.

Частота внутреннего высокочастотного RC-генератора (HSI) равна 16 МГц.

=== *_Третье задание:_*
_Настроить PLL источник тактовой частоты на 32 Мгц и подключить
его на системную шину._

_Прошить программу морганиями светодиодом - проверить, что они моргают
еще в 2 раза быстрее чем в пункте 2._

На рисунке 4 предсавлена настройка PLL источника тактовой частоты.

.Настройка PLL
image::Pics/file_4.png[]

Необходимо правильно настроить фазовую автоподстройку частоты (ФАПЧ).
Для этого нужно сначала использовать источник HSI (16 МГц), а от него пошли
далее по следующей схеме:

.Система тактирования микроконтроллера STM32F411
image::Pics/file_5.png[]

После того как частота была настроена правильно стало видно, что светодиод стал
моргать ещё быстрей, чем в пункте 2. Частота с использованием
ФАПЧ (PLL) равна 32 МГц.

== Ответы на вопросы

=== *_1. Что такое POD типы данных?_*

_POD_ типы в языке _C++_ это аббревиатура от "_Plain Old Data_",
что можно трактовать как "Простые данные в стиле C".

Все типы делятся на две группы: объектные типы и все
остальные. К не объектным типам относятся функции,
ссылки и тип _void_. У таких типов, нельзя узнать размер
с помощью операции _sizeof_.

Группа объектных типов содержит две подгруппы – POD и
не-POD типы.

*К POD-типам относятся:*

- все встроенные арифметические типы (включая _wchar_t_
и _bool_);

- перечисления, т.е. типы, объявленные с помощью ключевого
слова _enum_;

- указатели;

- POD-структуры (_struct_ или _class_) и POD-объединения
(_union_).

*Чтобы структура была POD-типом, она должна удовлетворять
следующим требованиям:*

- не иметь пользовательских конструкторов, деструктора или
копирующего оператора присваивания;

- не иметь базовых классов;

- не иметь виртуальных функций;

- не иметь защищенных (_protected_) или закрытых (_private_)
нестатических членов данных;

- не иметь не статических членов данных не-POD-типов
(или массивов из таких типов), а также ссылок.

Копирующий оператор присваивания – это такой не шаблонный
нестатический *operator=*, у которого есть строго один
параметр типа *X, X&, const X&, volatile X&* или
*const volatile X&*, где *X* – тип рассматриваемой структуры
или объединения.

Все оставшиеся объектные типы являются не-POD-типами.
Наличие квалификаторов _const_ и _volatile_ не влияет на
"POD-овость" типа.

POD типы были введены чтобы разделить работу со старыми
типами языка _С_ и новыми в _С++_. При работе с POD типами
известно их размещение в памяти, а так же работают все
средства из С. Например можно пользоваться функциями
_memset_, _memcopy_.

=== *_2. Назовите все виды типов в языке С++._*

Основные типы данных в C++:

- *_int_* — целочисленный тип данных.

- *_float_* — тип данных с плавающей запятой.

- *_double_* — тип данных с плавающей запятой двойной точности.

- *_char_* — символьный тип данных.

- *_bool_* — логический тип данных.

=== *_3. Что такое пользовательский тип?_*

_Пользовательские типы данных_ — это типы данных,
которые могут быть созданы пользователем на основе того,
что доступно в языке.

Ключевое слово _typedef_ в языке C++ позволяет создавать
пользовательские типы данных – для этого достаточно
определить новое имя типа данных для уже существующего
типа данных. При этом сам новый тип данных не создается,
а лишь определяется новое имя для уже существующего типа.
Благодаря использованию пользовательских типов можно
делать программы более гибкими: для этого иногда достаточно
изменить _typedef_-инструкции с помощью макросов подстановки
(*#define*). Использование пользовательских типов позволяет
также улучшить читабельность кода, поскольку для стандартных
типов данных с помощью typedef можно использовать
собственные описательные имена.

Общий формат записи инструкции для создания пользовательского
типа:

 _typedef_ тип новое_имя;

=== *_4. Назовите модификаторы типов._*

Модификаторы типов:

- *_signed_*;
- *_unsigned_*;
- *_long_*;
- *_short_*.

Модификаторы _signed_, _unsigned_, _long_ и _short_ могут
применяться к целым базовым типам. Кроме того, _signed_ и
_unsigned_ могут применяться к _char_, и _long_ можно применять
к _double_.

Модификаторы _signed_ и _unsigned_ также могут использоваться
в качестве префикса для _long_ или _short_ модификаторов.
Например, _unsigned long int_.

C++ допускает сокращенное обозначение для объявления
_unsigned_, _short_, или _long_ целых чисел. Вы можете просто
использовать слово _unsigned_, _short_ или _long_, без _int_.
Это автоматически подразумевает _int_.

=== *_5. Назовите правило установки размеров типов._*

На рисунке 1 представлена таблица с минимальными размерами
типов данных.

.Размеры типов С++
image::Pics/file1.png[]

=== *_6. Что делает оператор sizeof()?_*

Фактический размер переменных может отличаться на разных
компьютерах, поэтому для его определения используют
оператор _sizeof_.

*Оператор sizeof* — это унарный оператор, который вычисляет
и возвращает размер определенной переменной или определенного
типа данных в байтах.

Использование _sizeof_ помогает создавать переносимый код
для тех случаев, когда код зависит от размера стандартных
типов данных С.

=== *_7. Что характеризует тип std::size_t?_*

Тип _size_t_ -- базовый беззнаковый целочисленный тип
языка С/С++. Является типом результата, возвращаемого
оператором _sizeof_. Размер типа выбирается таким образом,
чтобы в него можно было записать максимальный размер
теоретически возможного массива любого типа.

Другими словами в переменную типа _size_t_ может быть
безопасно помещен указатель. Исключение составляют
указатели на функции классов, но это особый случай.

=== *_8. Назовите фиксированные типы целых в библиотеке std._*

Чтобы решить вопрос кроссплатформенности, в язык С++
добавили набор целочисленных типов фиксированного размера,
которые гарантированно имеют один и тот же размер на любой архитектуре:

.Фиксированные типы целых
image::Pics/file_2.png[]

=== *_9. Что такое псевдоним типа?_*

Средство языка программирования _C++_,
введённое в синтаксис для повышения
удобства обращения к пользовательским
и встроенным типам данных.

=== *_10. Что такое явное и неявное преобразование типа?_*

*Неявное преобразование типов*, когда компилятор автоматически
конвертирует один фундаментальный тип данных в другой.

*Явное преобразование типов*, когда разработчик использует один
из операторов явного преобразования для выполнения конвертации
объекта из одного типа данных в другой.

=== *_11. Какие явные преобразования типов вы знаете?_*

В языке _C++_ есть 4 вида операций явного преобразования типов:

- применение оператора *static_cast*;
- применение оператора *const_cast*;
- применение оператора *dynamic_cast*;
- применение оператора *reinterpret_cast*.

=== *_12. Что делает reinterpret_cast?_*

*reinterpret_cast* преобразует типы, несовместимыми друг с другом.

Он используется для преобразования:

- В свой собственный тип.
- Указателя в интегральный тип.
- Интегрального типа в указатель.
- Указателя одного типа в указатель другого типа.
- Указателя на функцию одного типа в указатель на функцию
другого типа.

=== *_13. Чем static_cast отличается от reinterpret_cast?_*

*static_cast* осуществляет правильную работу с адресами, в то
время как *reinterpret_cast* просто интерпретирует указатель,
так как "приказывает" программист, не меняя его значения.

=== *_14. Что такое ОЗУ и ПЗУ?_*

_ОЗУ (оперативное запоминающее устройство)_ является энергозависимой
памятью. Это означает, что информация, временно хранящаяся
в модуле, стирается при перезагрузке или выключении компьютера.
Поскольку информация хранится на транзисторах с электрическим питанием,
при отключении электрического тока данные исчезают.

_ПЗУ (постоянное запоминающее устройство)_ является энергонезависимой памятью. Это означает, что
информация хранится на микросхеме постоянно. Для хранения данных
этой памяти не нужно электропитание, данные записываются в
отдельные ячейки памяти в форме двоичного кода. Энергонезависимая
память используется для неизменяемых компонентов компьютера,
например, для загрузочной части программного обеспечения или
служебных команд встроенного ПО, которые запускают принтер.

=== *_15. Каков размер памяти ARM Cortex микроконтроллеров._*

Ядро ARM имеет 4 Гбайт последовательной памяти с
адресов 0x00000000 до 0xFFFFFFFF.

=== *_16. По какой архитектуре разработан ARM Cortex микроконтроллер?_*

По Гарвардской архитектуре.

=== *_17. В чем отличие Гарвардской архитектуры от архитектуры ФонНеймана?_*

Основное отличие в том, что архитектура ФонНеймана использует
единую память (общую шину данных), а Гарвардская предполагает
наличие нескольких шин (в оригинале две: шина данных и шина команд),
повышая таким образом скорость по сравнению со случаем
использования одной шины в архитектуре ФонНеймана.

=== *_18. Где располагаются локальные переменные?_*

Переменные, определенные внутри блока, называются *локальными*
переменными. Располагаются в регистрах или в стеке.

=== *_19. Где располагаются статические переменные?_*

Статические переменные размещаются в области глобальной памяти.

=== *_20. Где располагаются глобальные переменные?_*

Располагаются в области глобальной памяти.
Обычно глобальные переменные объявляют в верхней части кода,
ниже директив *#include*, но выше любого другого кода.

=== *_21. Что такое стек?_*

В *стек* можно положить данные, и можно данные забрать, причем
те данные которые были положены в стек последним, забираем
из стека первыми.

*Стек* – это организация памяти, выполненная компоновщиком.
На уровне микроконтроллера для работы со стеком есть специальные
ассемблерные команды (например _PUSH_ – положить регистры в стек,
и _POP_ – взять из стека). Так же для сохранения и считывания
данных из стека могут использоваться инструкции _STR_ и _LDR_.

Обычно в стеке сохраняются регистры когда вы вызываете
подпрограмму, или проваливаетесь в прерывание, для того,
чтобы когда вернуться обратно в вашу программу восстановить
весь контекст и все переменные. Кроме того, если в вашей функции
передается слишком много переменных и под все не хватит
регистров, то компилятор расположит их также на стеке.
Локальные переменные функции также создаются на стеке.

=== *_22. Что такое указатель?_*

*Указатель* – переменная, значением которой является адрес
ячейки памяти. То есть указатель ссылается на блок данных
из области памяти, причём на самое его начало. Указатель может
ссылаться на переменную или функцию. Для этого нужно знать адрес
переменной или функции.

=== *_23. Что такое разыменовывание указателя?_*

Операция *разыменования указателя* представляет выражение
в виде _*имя_указателя_. Эта операция позволяет получить
объект по адресу, который хранится в указателе.

=== *_24. Что означает взятие адреса?_*

*Оператор &* - это унарный оператор, возвращающий адрес операнда.
Например:

 р = &num;

помещает адрес переменной _num_ в _р_. Данный адрес соответствует
внутреннему положению переменной в компьютере. Он ничего не
делает со значением _num_. Операцию *&* можно рассматривать как
"_взятие адреса_". Следовательно, предыдущий оператор присваивания
можно прочитать как «_p_ получает адрес _num_».

=== *_25. Какие операции можно выполнять над указателями?_*

Указатели поддерживают ряд операций: присваивание, получение
адреса указателя, получение значения по указателю, некоторые
арифметические операции и операции сравнения.

=== *_26. Что такое константный указатель?_*

*Константный указатель* — это указатель, значение которого не может
быть изменено после инициализации.

Подобно обычным константным переменным, константный указатель
должен быть инициализирован значением при объявлении.
Это означает, что он всегда будет указывать на один и тот же
адрес.

=== *_27. Что такое указатель на константу?_*

*Указатель на константу* — это неконстантный указатель,
который указывает на неизменное значение. Для объявления
указателя на константное значение, используется ключевое слово
_const_ перед типом данных.

=== *_28. Что такое ссылка? В чем её отличие от указателя?_*

Ссылка — это объект, указывающий на определенные данные,
но не хранящий их. (Ссылка это псевдоним переменной).

- У ссылки нельзя взять адрес. Если применить оператор
взятия адреса к ней, то будет выведен адрес переменной,
на которую она ссылается.
- Ссылка ведет себя почти также как константный указатель.
Её нельзя изменять, складывать, вычитать.
- Ссылки нельзя сравнивать.
- Ссылка не может быть не проинициализирована.

Главное отличие ссылки от указателей: указатель это целое число,
для ссылки доступны только 2 операции: копирование и разыменование.

=== *_29. Что такое регистр?_*

Регистр это устройство для записи, хранения и считывания _n_-разрядных
двоичных данных и выполнения других операций над ними.

=== *_30. Что такое регистры общего назначения?_*

Регистры общего назначения - это сверхбыстрая память внутри процессора,
предназначенная для хранения адресов и промежуточных результатов вычислений
(регистр общего назначения/регистр данных) или данных, необходимых для работы
самого процессора.

=== *_31. Что такое регистры специального назначения?_*

Регистры специального назначения расположены в ОЗУ микроконтроллера и
используются для управления процессором и периферийными устройствами.

=== *_32. Как можно установить бит в регистре специального назначения?_*

Установить бит можно двумя способами:

1) Записать бит в некую ячейки по адресу регистра;

2) Записать бит используя специальный класс С++, через двоеточия, указывая
название регистра и ячейки.

=== *_33. Объясните как вызывается функция?_*

При вызове функции происходит примерно следующее:

- в стек помещается фрейм, содержащий:

1. обратный адрес (адрес инструкции, следующей за вызовом функции);

2. Аргументы функции, передаваемые через стек;

3. Память под локальные переменные;

4. Сохраненные копии всех регистров, модифицированных функцией, которые необходимо будет восстановить после того, как функция завершит свое выполнение.

- в оперативные регистры записываются аргументы функции, передаваемые через них;

- процессор переходит к точке начала выполнения функции.


=== *_34) Что такое трансляция?_*

*Трансляция* - это преобразование программы, представленной на одном из языков
программирования, в программу на другом языке,
в определенном смысле равносильную первой.


=== *_35) Что такое компоновка?_*

*Компоновка* - это один из этапов создания исполняемого файла.
*Компилировать* – проводить трансляцию машинной программы с проблемно-ориентированного языка на
машинно-ориентированный язык (создание объектного кода) для ее исполнения.

=== *_36) Как лучше организовывать структуру проекта и почему?_*

При создании структуры проекта стоит соблюдать иерархическую структуру файлов.
Это позволяет облегчить поиск требуемых компонентов.
Все существующие подгруппы разбивают файлы на логические группы.

.Правильные структуры проекта
image::Pics/file4.png[]
.Правильные структуры проекта
image::Pics/file5.png[]

=== *_37) Что такое операторы?_*

*Оператор* — это элемент языка, задающий полное описание действия,
которое необходимо выполнить. Каждый оператор представляет собой
законченную фразу языка программирования и определяет некоторый вполне
законченный этап обработки данных. В состав операторов могут входить
служебные слова, данные, выражения и другие операторы. В английском языке
данное
понятие обозначается словом _“statement”_, означающим также _“предложение”_.

=== *_38) Какие арифметические операторы вы знаете?_*

_Арифметические операторы_ предоставляют базовые арифметические
действия над типами, такие как сложение,
вычитание, деление, умножение, остаток от деления, присваивание.

.Арифметические операторы
image::Pics/file6.png[]

=== *_39) Какие логические операторы вы знаете?_*

Логические операторы предоставляют действия над булевым типов.
Результат действия этих операторов может быть только _true_ или _false_.

.Логические операторы
image::Pics/file7.png[]

=== *_40) Какие побитовые операторы вы знаете?_*

_Побитовые операторы_ предоставляют действия с битами.

.Побитовые операторы
image::Pics/file8.png[]

=== *_41) Приведите пример переопределения оператора_*

Одна из целей ООП – создание необходимых
пользователю форм представления (типов данных) в виде классов.
Естественное желание, сделать их неотличимыми до такой степени,
чтобы с ними можно было работать как с обычными переменными базовых типов.
Переопределение операций обеспечивает перепрограммирование операций таким образом,
что в качестве
операндов в них могут использоваться объекты интересующего нас типа.

_Пример переопределения опреатора:_

// переопределение операций

    poly operator+(poly T) // Переопределение сложения - конвейер значений
        {
        T.add(*this);      // Второй операнд по значению (копия)
        return T;          // Добавление первого к копии второго
        }


=== *_42) Какие еще операторы вы знаете?_*

_+, -, *, /, %, ^, &, |, ~, !, ,, =, <, >, <=, >=, ++, –-, <<, >>,
==, !=, &&, ||, +=, -=, /=,
%=, ^=, &=, |=, *=, <<=, >>=, [], (), ->, -> *,

_new, new[],
delete, delete[]._

=== *_43) Как сбросить бит с помощью битовых операторов?_*

_x &= ~(1 << номер бита)_

=== *_44) Как установить бит с помощью битовых операторов?_*

_x |= (1 << номер бита)_

=== *_45) Как поменять значение бита с помощью битовых операторов?_*

_x ^= (1 << номер бита)_

=== *_46) Какой микроконтроллер на отладочной плате XNUCLE ST32F411?_*

На отладочной плате _XNUCLE ST32F411_ находится микроконтроллер _ST32F411RE_.

=== *_47) Какие блоки входят в состав микроконтроллера STM32F411?_*

Функциональные блоки микроконтроллера _STM32F411_ представлены ниже:

.Функциональные блоки микроконтроллера STM32F411
image::Pics/file9.png[]

=== *_48)В чем отличие ядра CortexM4 от CortexM3?_*

Наличие _DSP_-инструкций, которые
существенно ускоряют обработку потоковых данных.

Возможности _DSP_, входящего в состав M4, позволяют
параллельно выполнять четыре операции сложения/вычитания
для 8-ми разрядных чисел или две операции сложения/вычитания
с 16-ти разрядными операндами. Также реализовано умножение за один цикл,
при этом для 16-ти разрядных чисел возможно параллельное исполнение двух операций.

В серии CortexM4F еще есть блок для работы с плавающей точкой. Чего нет в CortexM3

=== *_49) Назовите основные характеристики микроконтроллера STM32F411._*

Основные характеристики микроконтроллера STM32F411 представлены ниже:

.Основные характеристики
image::Pics/file10.png[]

=== *_50) Назовите дополнительные характеристики микроконтроллера STM32F411._*

- Настраиваемые источники тактовой частоты;

- Настраиваемые на различные функции порты;

- Внутренний температурный сенсор;

- Таймеры с настраиваемым модулем ШИМ;

- DMA для работы с модулями (SPI, UART, ADC… );

- 12 разрядный ADC последовательного приближения;

- Часы реального времени;

- Системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ.

=== *_51) Какие источники тактирования есть у микроконтроллера STM32F411_*

Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:​

- HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​

- HSE (high-speed external) — внешний высокочастотный генератор.​

- PLL — система ФАПЧ. Представляет собой набор из умножителей и делителей, исходный
сигнал он получает от HSI или HSE, а на выходе формирует другую частоту.

- LSI (low-speed internal) — внутренний низкочастотный генератор.

- LSE (low-speed external) — внешний низкочастотный генератор.




=== *_52) Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411._*

1. Определить какие источники частоты нужны​. Например, _PLL_ нужен для USB​

2. Включить нужный источник​. Используя _Clock Control register (RCC::CR)​_

3. Дождаться стабилизации источника. Используя соответствующие биты _(..RDY) Clock Control register ​(RCC::CR)_

4. Назначить нужный источник на системную частоту​. Используя __Clock Configuration Register (RCC::CFGR)​
__
5. Дождаться пока источник не переключиться на системную частоту​. Используя __Clock Configuration Register (RCC::CFGR)​__



=== *_53) Что такое ФАПЧ?_*

_ФАПЧ_ - система автоматического регулирования, подстраивающая фазу
управляемого генератора так, чтобы она
была равна фазе опорного сигнала, либо отличалась на известную функцию от времени.


=== *_54) Что делает следующий код?_*

    int main()
    {
        int StudentUdacha = 10;
        int PrepodUdachca = 0 ;
        StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
        PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
        StudentUdacha ^= PrepodUdachca ;
    }

Сначала присваиваем переменной _StudentUdacha_ значение _10_ (1010).

Затем присваиваем переменной _PrepodUdachca_ значение _0_ (0).

С помощью операции исключающего ИЛИ запишем в переменную _StudentUdacha_
значение 10 (1010)

Далее, в переменную _PrepodUdachca_ с помощью операции исключающего ИЛИ запишем
значение 10 (1010)

В конце, используем инверсию и получаем, что в переменную _StudentUdacha_ записалось
значение 0.

С помощью данного кода можно поменять
местами значения переменных без использования буферной переменной.


